gof(oc$naturalness,oc$Distance) # r = .91, r2 = .83
library(hydroGOF)
setwd("~/Documents/git/cocolab/adjective_ordering/experiments/analysis")
# Bootstrap 95% CI for R-Squared
library(boot)
# function to obtain R-Squared from the data
rsq <- function(formula, data, indices) {
d <- data[indices,] # allows boot to select sample
fit <- lm(formula, data=d)
return(summary(fit)$r.square)
}
source("splithalf.R")
######
## Mean results by class plot
######
r = read.csv("~/Documents/git/cocolab/adjective_ordering/experiments/analysis/results-by-class.csv",header=T)
r$X.1 = NULL
r$X = NULL
o = read.csv("~/Documents/git/cocolab/adjective_ordering/experiments/analysis/naturalness-duplicated.csv",header=T)
head(o)
o_s = bootsSummary(data=o, measurevar="correctresponse", groupvars=c("correctclass"))
o_s$expt = "preference"
head(o_s)
colnames(o_s) <- c("class","N","average","YMin","YMax","expt")
new_r = rbind(r[r$expt!="preference",],o_s)
bootsSummary <- function(data=NULL, measurevar, groupvars=NULL, na.rm=FALSE,
conf.interval=.95, .drop=TRUE, n_boots_samps=10000) {
require(plyr)
# New version of length which can handle NA's: if na.rm==T, don't count them
length2 <- function (x, na.rm=FALSE) {
if (na.rm) sum(!is.na(x))
else       length(x)
}
# This does the summary. For each group's data frame, return a vector with
# N, mean, and sd
datac <- ddply(data, groupvars, .drop=.drop,
.fun = function(xx, col) {
c(N    = length2(xx[[col]], na.rm=na.rm),
mean = mean   (xx[[col]], na.rm=na.rm),
bootsci_high = quantile( #doesn't play nice with na.rm
replicate(n_boots_samps, mean(sample(xx[[col]], replace = TRUE))),
c(0.025, 0.975))[["97.5%"]],
bootsci_low = quantile( #doesn't play nice with na.rm
replicate(n_boots_samps, mean(sample(xx[[col]], replace = TRUE))),
c(0.025, 0.975))[["2.5%"]]
)
},
measurevar
)
# Rename the "mean" column
datac <- rename(datac, c("mean" = measurevar))
return(datac)
}
new_r$expt = factor(new_r$expt,levels=c("preference","corpus","subjectivity","faultless"))
ggplot(data=new_r,aes(x=reorder(class,-average,mean),y=average,fill=expt))+
geom_bar(stat="identity",position=position_dodge(.9),color="black")+
geom_errorbar(aes(ymin=YMin, ymax=YMax, x=reorder(class,-average,mean), width=0.1),position=position_dodge(.9))+
xlab("\nadjective class")+
labs(fill="experiment") +
ylab("")+
ylim(0,1)+
theme_bw()+
scale_fill_manual(values=c("gray25","gray75","gray50","gray100"))
library(ggplot2)
setwd("~/Documents/git/cocolab/adjective_ordering/experiments/analysis")
# Bootstrap 95% CI for R-Squared
library(boot)
# function to obtain R-Squared from the data
rsq <- function(formula, data, indices) {
d <- data[indices,] # allows boot to select sample
fit <- lm(formula, data=d)
return(summary(fit)$r.square)
}
source("splithalf.R")
######
## Mean results by class plot
######
r = read.csv("~/Documents/git/cocolab/adjective_ordering/experiments/analysis/results-by-class.csv",header=T)
r$X.1 = NULL
r$X = NULL
o = read.csv("~/Documents/git/cocolab/adjective_ordering/experiments/analysis/naturalness-duplicated.csv",header=T)
head(o)
o_s = bootsSummary(data=o, measurevar="correctresponse", groupvars=c("correctclass"))
o_s$expt = "preference"
head(o_s)
colnames(o_s) <- c("class","N","average","YMin","YMax","expt")
new_r = rbind(r[r$expt!="preference",],o_s)
new_r$expt = factor(new_r$expt,levels=c("preference","corpus","subjectivity","faultless"))
ggplot(data=new_r,aes(x=reorder(class,-average,mean),y=average,fill=expt))+
geom_bar(stat="identity",position=position_dodge(.9),color="black")+
geom_errorbar(aes(ymin=YMin, ymax=YMax, x=reorder(class,-average,mean), width=0.1),position=position_dodge(.9))+
xlab("\nadjective class")+
labs(fill="experiment") +
ylab("")+
ylim(0,1)+
theme_bw()+
scale_fill_manual(values=c("gray25","gray75","gray50","gray100"))
#ggsave("~/Documents/git/cocolab/adjective_ordering/writing/short-paper/plots/expt_results-new.pdf",height=2.1,width=6.75)
######
## Correlation coefficients and CIs
######
#load in faultless disagreement
f = read.csv("faultless_results.csv",header=T)
head(f)
f_agr_pred = aggregate(response~predicate,data=f,mean)
f_agr_class = aggregate(response~class,data=f,mean)
#load in subjectivity
s = read.csv("subjectivity_results.csv",header=T)
head(s)
s_agr_pred = aggregate(response~predicate,data=s,mean)
s_agr_class = aggregate(response~class,data=s,mean)
# combine subjectivity and faultless
sf <- s_agr_pred
sf$faultless = f_agr_pred$response[match(sf$predicate,f_agr_pred$predicate)]
# CLASS compare faultless and subjectivity
gof(s_agr_class$response,f_agr_class$response) # r = .96, r2 = .93
# PREDICATE compare faultless and subjectivity
gof(s_agr_pred$response,f_agr_pred$response) # r = .94, r2 = .89
# get 95% CI
results <- boot(data=sf, statistic=rsq, R=10000, formula=response~faultless)
boot.ci(results, type="bca") # 95%   ( 0.8174,  0.9291 )
#load in corpus
c_agr_pred = read.csv("~/Documents/git/cocolab/adjective_ordering/experiments/analysis/corpus_pred_averages.csv",header=T)
c_agr_class = read.csv("~/Documents/git/cocolab/adjective_ordering/experiments/analysis/corpus_class_averages.csv",header=T)
#load in naturalness preferences
o = read.csv("~/Documents/git/cocolab/adjective_ordering/experiments/analysis/naturalness-duplicated.csv",header=T)
head(o)
o_agr_pred = aggregate(correctresponse~predicate*correctclass,data=o,mean)
head(o_agr_pred)
#o_agr_pred = read.csv("~/Documents/git/cocolab/adjective_ordering/experiments/analysis/average-naturalness.csv",header=T)
# combine naturalness and corpus
oc <- c_agr_pred
oc$naturalness = o_agr_pred$correctresponse[match(oc$Adjective,o_agr_pred$predicate)]
# PREDICATE compare naturalness and corpus distance
gof(oc$naturalness,oc$Distance) # r = .91, r2 = .83
# get 95% CI
results <- boot(data=oc, statistic=rsq, R=10000, formula=naturalness~Distance)
boot.ci(results, type="bca") # 95%   ( 0.6408,  0.9031 )
summary(f)
unique(x$workerid)
unique(f$workerid)
new_r$expt = factor(new_r$expt,levels=c("preference","corpus","faultless","subjectivity"))
ggplot(data=new_r,aes(x=reorder(class,-average,mean),y=average,fill=expt))+
geom_bar(stat="identity",position=position_dodge(.9),color="black")+
geom_errorbar(aes(ymin=YMin, ymax=YMax, x=reorder(class,-average,mean), width=0.1),position=position_dodge(.9))+
xlab("\nadjective class")+
labs(fill="experiment") +
ylab("")+
ylim(0,1)+
theme_bw()+
scale_fill_manual(values=c("gray25","gray75","gray50","gray100"))
ggsave("~/Documents/git/cocolab/adjective_ordering/writing/short-paper/plots/expt_results-new.pdf",height=2.1,width=6.75)
gof(s_agr_pred$response,f_agr_pred$response) # r = .94, r2 = .89
o_agr_pred$faultless = f_agr_pred$response[match(o_agr_pred$predicate,f_agr_pred$predicate)]
gof(o_agr_pred$correctresponse,o_agr_pred$faultless) # r = .94, r2 = .88
results <- boot(data=o_agr_pred, statistic=rsq, R=10000, formula=correctresponse~faultless)
boot.ci(results, type="bca") # 95%   ( 0.7713,  0.9479 )
head(o_agr_class)
o_agr_class = aggregate(correctresponse~correctclass,data=o,mean)
head(f_Agr)
head(f_agr)
head(f_agr_class)
head(o_agr_class)
o_agr_class$faultless = f_agr_class$response[match(o_agr_class$correctclass,f_agr_class$class)]
gof(o_agr_class$correctresponse,o_agr_class$faultless) # r = .94, r2 = .88
gof(o_agr_class$correctresponse,o_agr_class$faultless) # r = .93, r2 = .86
results <- boot(data=o_agr_class, statistic=rsq, R=10000, formula=correctresponse~faultless)
boot.ci(results, type="bca") # 95%   ( 0.7713,  0.9479 )
a_agr_class
o_agr_class
setwd("~/Documents/git/cocolab/adjective_ordering/experiments/3-order-preference/Submiterator-master")
d = read.table("order-preference-trials.tsv",sep="\t",header=T)
head(d)
s = read.table("order-preference-subject_information.tsv",sep="\t",header=T)
head(s)
d$language = s$language[match(d$workerid,s$workerid)]
unique(d$language)
all <- d
# only native English speakers (n=45)
d = d[d$language!="DUTCH, ENGLISH"&d$language!="English, Spanish"&d$language!="Vietnamese"&d$language!="Spanish",]
unique(d$workerid)
summary(d)
o <- d
o$configuration = paste(o$predicate1,o$predicate2)
o$class_configuration = paste(o$class1,o$class2)
o$rightconfiguration = paste(o$predicate2,o$predicate1)
o$right_class_configuration = paste(o$class2,o$class1)
#o$rightpredicate1 = o$predicate2
#o$rightpredicate2 = o$predicate1
o$rightresponse = 1-o$response
agr = o %>%
select(configuration,rightconfiguration,response,rightresponse,workerid,noun,nounclass,class_configuration,right_class_configuration) %>%
gather(predicateposition,predicate,configuration:rightconfiguration,-workerid,-noun,-nounclass,-class_configuration,-right_class_configuration)
library(ggplot2)
library(reshape2)
library(lme4)
library(hydroGOF)
agr = o %>%
select(predicate1,rightpredicate1,response,rightresponse,workerid,noun,nounclass,class1,class2) %>%
gather(predicateposition,predicate,predicate1:rightpredicate1,-workerid,-noun,-nounclass,-class1,-class2)
?unload
?unmount
?remove
library(dplyr)
agr = o %>%
select(predicate1,rightpredicate1,response,rightresponse,workerid,noun,nounclass,class1,class2) %>%
gather(predicateposition,predicate,predicate1:rightpredicate1,-workerid,-noun,-nounclass,-class1,-class2)
o <- d
o$configuration = paste(o$predicate1,o$predicate2)
o$class_configuration = paste(o$class1,o$class2)
o$rightconfiguration = paste(o$predicate2,o$predicate1)
o$right_class_configuration = paste(o$class2,o$class1)
#o$rightpredicate1 = o$predicate2
#o$rightpredicate2 = o$predicate1
o$rightresponse = 1-o$response
agr = o %>%
select(configuration,rightconfiguration,response,rightresponse,workerid,noun,nounclass,class_configuration,right_class_configuration) %>%
gather(predicateposition,predicate,configuration:rightconfiguration,-workerid,-noun,-nounclass,-class_configuration,-right_class_configuration)
library(tidyr)
library(tidyr)
agr = o %>%
select(configuration,rightconfiguration,response,rightresponse,workerid,noun,nounclass,class_configuration,right_class_configuration) %>%
gather(predicateposition,predicate,configuration:rightconfiguration,-workerid,-noun,-nounclass,-class_configuration,-right_class_configuration)
agr$correctresponse = agr$response
agr[agr$predicateposition == "rightconfiguration",]$correctresponse = agr[agr$predicateposition == "rightconfiguration",]$rightresponse
agr$correctclass = agr$class_configuration
agr[agr$predicateposition == "rightconfiguration",]$correctclass = agr[agr$predicateposition == "rightconfiguration",]$right_class_configuration
head(agr[agr$predicateposition == "rightconfiguration",])
head(d)
head(agr)
o <- d
o$rightpredicate1 = o$predicate2
o$rightpredicate2 = o$predicate1
head(o)
o$rightresponse = 1-o$response
agr = o %>%
select(predicate1,rightpredicate1,response,rightresponse,workerid,noun,nounclass,class1,class2) %>%
gather(predicateposition,predicate_configuration,predicate1:rightpredicate1,-workerid,-noun,-nounclass,-class1,-class2)
head(agr)
unique(agr$predicateposition)
o <- d
head(o)
o <- d
o$configuration = paste(o$predicate1,o$predicate2)
o$class_configuration = paste(o$class1,o$class2)
o$rightconfiguration = paste(o$predicate2,o$predicate1)
o$right_class_configuration = paste(o$class2,o$class1)
#o$rightpredicate1 = o$predicate2
#o$rightpredicate2 = o$predicate1
o$rightresponse = 1-o$response
agr = o %>%
select(configuration,rightconfiguration,response,rightresponse,workerid,noun,nounclass,class_configuration,right_class_configuration) %>%
gather(predicateposition,correct_configuration,configuration:rightconfiguration,-workerid,-noun,-nounclass,-class_configuration,-right_class_configuration)
head(agr)
agr$correctresponse = agr$response
agr[agr$predicateposition == "rightconfiguration",]$correctresponse = agr[agr$predicateposition == "rightconfiguration",]$rightresponse
agr$correctclass = agr$class_configuration
agr[agr$predicateposition == "rightconfiguration",]$correctclass = agr[agr$predicateposition == "rightconfiguration",]$right_class_configuration
head(agr[agr$predicateposition == "rightconfiguration",])
head(o)
agr$response = NULL
agr$rightresponse = NULL
head(agr)
unqique(agr$predicateposition)
unique(agr$predicateposition)
agr$class_configuration = NULL
head(agr)
agr$right_class_configuration = NULL
head(agr) #2340
length(agr) #2340
agr
nrow(agr) #2340
write.csv(agr,"~/Documents/git/cocolab/adjective_ordering/experiments/analysis/naturalness-configuration-duplicated.csv")
o = read.csv("~/Documents/git/cocolab/adjective_ordering/experiments/analysis/naturalness-configuration-duplicated.csv",header=T)
head(o)
o$predicate = o$correct_configuration
o$class = o$correctclass
o$workerID = o$workerid + 1
o$response = o$correctresponse
# get Spearman-Brown prophecy (explainable variance)
prophet(splithalf_class(o, 100), 2) # 0.94 class configuration
source("splithalf.R")
setwd("~/Documents/git/cocolab/adjective_ordering/experiments/analysis")
source("splithalf.R")
prophet(splithalf_class(o, 100), 2) # 0.94 class configuration
head(o)
summary(o)
splithalf_class(o, 100)
data <- o
cors <- numeric(0)
t <- 1
while (t <= N) {
# assumes your data frame has a column called workerID, and they go from 1 to nWorkers
nWorkers <- length(unique(data$workerID))
indices <- seq_len(nWorkers)
workers1 <- sample(indices, nWorkers / 2)
workers2 <- indices[!indices %in% workers1]
subset1 <- subset(data, workerID %in% workers1)
subset2 <- subset(data, workerID %in% workers2)
##########
# hard-coded, should modify
##########
subset1.mean <- aggregate(data=subset1, response ~ predicate , FUN=mean)
subset2.mean <- aggregate(data=subset2, response ~ predicate , FUN=mean)
subset1.mean <- rename(subset1.mean, replace=c("response" = "mean1"))
subset2.mean <- rename(subset2.mean, replace=c("response" = "mean2"))
subset.comp <- join(subset1.mean, subset2.mean, by=c("predicate"))
subset.comp = na.omit(subset.comp)
r <- with(subset.comp, cor(mean1, mean2))
if (!is.na(r)) {
t <- t+1
cors <- c(cors, r)
}
}
return(mean(cors))
}
nWorkers <- length(unique(data$workerID))
nWorkers
indices <- seq_len(nWorkers)
indices
workers1 <- sample(indices, nWorkers / 2)
workers2 <- indices[!indices %in% workers1]
subset1 <- subset(data, workerID %in% workers1)
subset2 <- subset(data, workerID %in% workers2)
head(subset1)
head(subset2)
nrow(subset1)
nrow(subset2)
nrow(data)
1196+936
data$workerID = as.factor(as.character(data$workerID))
data$workerID = factor(data$workerid,labels=seq(1,45))
cors <- numeric(0)
t <- 1
nWorkers <- length(unique(data$workerID))
indices <- seq_len(nWorkers)
workers1 <- sample(indices, nWorkers / 2)
workers2 <- indices[!indices %in% workers1]
subset1 <- subset(data, workerID %in% workers1)
subset2 <- subset(data, workerID %in% workers2)
nrow(subset1)
nrow(subset2)
1144+1196
splithalf_pred <- function(data, N) {
#data <- o
data$workerID = as.factor(as.character(data$workerID))
#data$workerid=NULL
data$workerID = factor(data$workerid,labels=seq(1,45))
cors <- numeric(0)
t <- 1
while (t <= N) {
# assumes your data frame has a column called workerID, and they go from 1 to nWorkers
nWorkers <- length(unique(data$workerID))
indices <- seq_len(nWorkers)
workers1 <- sample(indices, nWorkers / 2)
workers2 <- indices[!indices %in% workers1]
subset1 <- subset(data, workerID %in% workers1)
subset2 <- subset(data, workerID %in% workers2)
##########
# hard-coded, should modify
##########
subset1.mean <- aggregate(data=subset1, response ~ predicate , FUN=mean)
subset2.mean <- aggregate(data=subset2, response ~ predicate , FUN=mean)
subset1.mean <- rename(subset1.mean, replace=c("response" = "mean1"))
subset2.mean <- rename(subset2.mean, replace=c("response" = "mean2"))
subset.comp <- join(subset1.mean, subset2.mean, by=c("predicate"))
subset.comp = na.omit(subset.comp)
r <- with(subset.comp, cor(mean1, mean2))
if (!is.na(r)) {
t <- t+1
cors <- c(cors, r)
}
}
return(mean(cors))
}
prophet(splithalf_pred(o, 100), 2) # 0.80 predicate configuration
data <- o
data$workerID = as.factor(as.character(data$workerID))
#data$workerid=NULL
data$workerID = factor(data$workerid,labels=seq(1,45))
cors <- numeric(0)
t <- 1
nWorkers <- length(unique(data$workerID))
nWorkers
indices <- seq_len(nWorkers)
workers1 <- sample(indices, nWorkers / 2)
workers2 <- indices[!indices %in% workers1]
subset1 <- subset(data, workerID %in% workers1)
subset2 <- subset(data, workerID %in% workers2)
nrow(subset1)
nrow(subset2)
1144+1196
nrow(data)
subset1.mean <- aggregate(data=subset1, response ~ predicate , FUN=mean)
subset2.mean <- aggregate(data=subset2, response ~ predicate , FUN=mean)
subset1.mean <- rename(subset1.mean, replace=c("response" = "mean1"))
subset2.mean
detach("package:plyr", unload=TRUE)
detach("package:dplyr", unload=TRUE)
subset1.mean <- rename(subset1.mean, replace=c("Comp.1" = "mean1"))
library(rename)
??rename
detach("package:plyr", unload=TRUE)
library(dplyr)
subset1.mean <- aggregate(data=subset1, Comp.1 ~ imageID + utterance, FUN=mean)
subset1.mean <- aggregate(data=subset1, response ~ predicate , FUN=mean)
subset2.mean <- aggregate(data=subset2, response ~ predicate , FUN=mean)
splithalf_pred <- function(data, N) {
#data <- o
#data$workerID = as.factor(as.character(data$workerID))
#data$workerid=NULL
#data$workerID = factor(data$workerid,labels=seq(1,45))
cors <- numeric(0)
t <- 1
while (t <= N) {
# assumes your data frame has a column called workerID, and they go from 1 to nWorkers
nWorkers <- length(unique(data$workerID))
indices <- seq_len(nWorkers)
workers1 <- sample(indices, nWorkers / 2)
workers2 <- indices[!indices %in% workers1]
subset1 <- subset(data, workerID %in% workers1)
subset2 <- subset(data, workerID %in% workers2)
##########
# hard-coded, should modify
##########
subset1.mean <- aggregate(data=subset1, response ~ predicate , FUN=mean)
subset2.mean <- aggregate(data=subset2, response ~ predicate , FUN=mean)
subset1.mean <- rename(subset1.mean, replace=c("response" = "mean1"))
subset2.mean <- rename(subset2.mean, replace=c("response" = "mean2"))
subset.comp <- join(subset1.mean, subset2.mean, by=c("predicate"))
subset.comp = na.omit(subset.comp)
r <- with(subset.comp, cor(mean1, mean2))
if (!is.na(r)) {
t <- t+1
cors <- c(cors, r)
}
}
return(mean(cors))
}
splithalf_class <- function(data, N) {
#data <- o
#data$workerID = as.factor(as.character(data$workerID))
#data$workerid=NULL
#o$workerID = factor(o$workerid,labels=seq(1,45))
cors <- numeric(0)
t <- 1
while (t <= N) {
# assumes your data frame has a column called workerID, and they go from 1 to nWorkers
nWorkers <- length(unique(data$workerID))
indices <- seq_len(nWorkers)
workers1 <- sample(indices, nWorkers / 2)
workers2 <- indices[!indices %in% workers1]
subset1 <- subset(data, workerID %in% workers1)
subset2 <- subset(data, workerID %in% workers2)
##########
# hard-coded, should modify
##########
subset1.mean <- aggregate(data=subset1, response ~ class , FUN=mean)
subset2.mean <- aggregate(data=subset2, response ~ class , FUN=mean)
subset1.mean <- rename(subset1.mean, replace=c("response" = "mean1"))
subset2.mean <- rename(subset2.mean, replace=c("response" = "mean2"))
subset.comp <- join(subset1.mean, subset2.mean, by=c("class"))
subset.comp = na.omit(subset.comp)
r <- with(subset.comp, cor(mean1, mean2))
if (!is.na(r)) {
t <- t+1
cors <- c(cors, r)
}
}
return(mean(cors))
}
prophet(splithalf_pred(o, 100), 2) # 0.80 predicate configuration
data <- o
cors <- numeric(0)
t <- 1
nWorkers <- length(unique(data$workerID))
indices <- seq_len(nWorkers)
workers1 <- sample(indices, nWorkers / 2)
workers2 <- indices[!indices %in% workers1]
subset1 <- subset(data, workerID %in% workers1)
subset2 <- subset(data, workerID %in% workers2)
##########
# hard-coded, should modify
##########
subset1.mean <- aggregate(data=subset1, response ~ predicate , FUN=mean)
subset2.mean <- aggregate(data=subset2, response ~ predicate , FUN=mean)
subset1.mean <- rename(subset1.mean, replace=c("response" = "mean1"))
detach("package:plyr", unload=TRUE)
